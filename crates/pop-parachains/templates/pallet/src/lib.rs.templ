//! # ^^name^^ pallet
//! Please, document your pallet properly
//! Learn more about everything related to Polkadot SDK development at https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/index.html
//! - [`Config]
//! - [`Call`]
#![cfg_attr(not(feature = "std"), no_std)]

use frame::prelude::*;

{{ for common_type in pallet_common_types }}
{{- match common_type -}}
{{- when TemplatePalletConfigCommonTypes::Currency -}}
use frame::traits::{fungible::{Inspect, Mutate, InspectHold, MutateHold, InspectFreeze, MutateFreeze}, VariantCount};

{{ else -}}
{{- endmatch -}}
{{- endfor -}}
{{ if pallet_default_config }}
pub mod config_preludes;

{{ endif -}}

use pallet::*;

// A module where the main logic of the pallet is stored
mod pallet_logic;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

#[frame_support::pallet]
pub mod pallet {
	use super::*;

    {{ for common_type in pallet_common_types }}
    {{- match common_type -}}
    {{- when TemplatePalletConfigCommonTypes::RuntimeOrigin -}}
    /// An alias referencing the RuntimeOrigin config type.
    pub type RuntimeLocalOrigin<T> = <T as Config>::RuntimeOrigin;

    {{ when TemplatePalletConfigCommonTypes::Currency -}}
    /// An alias referencing the native currency's balance of an account.
    pub type BalanceOf<T> = <<T as Config>::Currency as fungible::Inspect<<T as frame_system::Config>::AccountId>>::Balance;

    /// A reason for the pallet placing a hold on funds.
	#[pallet::composite_enum]
	pub enum HoldReason {
		/// Some hold reason
		#[codec(index = 0)]
		SomeHoldReason,
	}

    {{ else -}}
    {{- endmatch -}}
    {{- endfor -}}

    /// A helful struct. You can use this kind of struct as a value in the pallet's storage. It helps storing related information together. It's possible to store a SCALE compact number using this kind of struct as well :)
    #[derive(TypeInfo, Encode, Decode, MaxEncodedLen, PartialEq, RuntimeDebugNoBound)]
	#[scale_info(skip_type_params(T))]
	pub struct SomeHelpfulStruct<T: Config> {
		pub account_id: T::AccountId,
		#[codec(compact)]
		pub number: u32,
	}

    #[pallet::pallet]
	pub struct Pallet<T>(_);
    {{ if pallet_default_config }}
    #[pallet::config(with_default)]
    {{- else }}
    #[pallet::config]
    {{- endif }}
    pub trait Config: frame_system::Config{
        {{- for common_type in pallet_common_types -}}
        {{- match common_type -}}
        {{- when TemplatePalletConfigCommonTypes::RuntimeEvent }}
        /// The aggregated event type of the runtime.
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;

        {{ when TemplatePalletConfigCommonTypes::RuntimeOrigin -}}
        /// The aggregated origin type of the runtime.
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
        {{- if !pallet_custom_internal_origin_variants.is_empty() }}
        type RuntimeOrigin: From<OriginFor<Self>> + From<Origin<Self>> + Into<Result<Origin<Self>,RuntimeLocalOrigin<Self>>>;

        {{ else }}
        type RuntimeOrigin: From<OriginFor<Self>>;

        {{ endif -}}
        {{- when TemplatePalletConfigCommonTypes::Currency }}
        /// A reason for placing a hold on funds
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeHoldReason: From<HoldReason>;

        /// A reason for placing a freeze on funds
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeFreezeReason: VariantCount;
        
        /// Type to access the native currency of the blockchain
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type Currency: fungible::Inspect<Self::AccountId>
			+ fungible::Mutate<Self::AccountId>
			+ fungible::hold::Inspect<Self::AccountId>
			+ fungible::hold::Mutate<Self::AccountId, Reason = Self::RuntimeHoldReason>
			+ fungible::freeze::Inspect<Self::AccountId>
			+ fungible::freeze::Mutate<Self::AccountId>;
            
        {{ else -}}
        {{- endmatch -}}
        {{- endfor -}}
        {{- for config_type in pallet_config_types-}}
        /// Some docs for this type
        {{- match config_type.0 -}}
        {{- when TemplatePalletConfigTypesMetadata::Constant }}
        #[pallet::constant]
        {{- else -}}
        {{- endmatch -}}
        {{- match config_type.1 -}}
        {{- when TemplatePalletConfigTypesDefault::NoDefaultBounds }}
        #[pallet::no_default_bounds]
        {{- when TemplatePalletConfigTypesDefault::NoDefault }}
        #[pallet::no_default]
        {{- else -}}
        {{- endmatch }}
        type ^^config_type.2^^ = todo!();

        {{ endfor }}
    }

    {{ for storage in pallet_storage }}
    /// Some docs for this storage type
    #[pallet::storage]
    {{- match storage.0 -}}
    {{- when TemplatePalletStorageTypes::StorageValue }}
    pub type ^^storage.1^^ = StorageValue<Value = todo!()>;

    {{ when TemplatePalletStorageTypes::StorageMap }}
    pub type ^^storage.1^^ = StorageMap<todo!(), Key = todo!(), Value = todo!()>;

    {{ when TemplatePalletStorageTypes::CountedStorageMap }}
    pub type ^^storage.1^^ = CountedStorageMap<Hasher = todo!(), Key = todo!(), Value = todo!()>;

    {{ when TemplatePalletStorageTypes::StorageDoubleMap }}
    pub type ^^storage.1^^ = StorageDoubleMap<Hasher1 = todo!(), Key1 = todo!(), Hasher2 = todo!(), Key2 = todo!(), Value = todo!()>;

    {{ when TemplatePalletStorageTypes::StorageNMap }}
    pub type ^^storage.1^^= StorageNMap<
        Key = (
            NMapKey<todo!(), todo!()>,
            NMapKey<todo!(), todo!()>,
            NMapKey<todo!(), todo!()>,
        ),
        Value = todo!()
    >;

    {{ when TemplatePalletStorageTypes::CountedStorageNMap }}
    pub type ^^storage.1^^ = CountedStorageNMap<
        Key = (
            NMapKey<todo!(), todo!()>,
            NMapKey<todo!(), todo!()>,
            NMapKey<todo!(), todo!()>,
        ),
        Value = todo!()
    >;
    
    {{ endmatch -}}
    {{- endfor -}}

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
        /// Someone did something
        SomeoneDidSomething { who: T::AccountId}
    }

    #[pallet::error]
	pub enum Error<T> {
		/// SomethingWentWrong
		SomethingWentWrong,
    }

    {{ if pallet_genesis }}
    #[pallet::genesis_config]
    pub struct GenesisConfig<T: Config> {
        /// This is just an example of genesis configuration, don't neeed to use a bool
        pub some_genesis_config: bool
    }

    #[pallet::genesis_build]
    impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
        fn build(&self) {
            if self.some_genesis_config{
                todo!("This is just an example, maybe you wanna initialize some storage");
            }
        }
    }

    {{ endif -}}

    {{- if !pallet_custom_internal_origin_variants.is_empty() }}
    #[pallet::origin]
    #[derive(PartialEq, Eq, Clone, RuntimeDebug, Encode, Decode, TypeInfo, MaxEncodedLen)]
    pub enum Origin<T:Config> {
        {{- for variant in pallet_custom_internal_origin_variants }}
            ^^variant^^,
        {{- endfor -}}
    }

    {{ endif -}}

    #[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        fn integrity_test(){
            todo!("Maybe ensure something about your config types...");
        }

		#[cfg(feature = "try-runtime")]
		fn try_state(_: BlockNumberFor<T>) -> Result<(), sp_runtime::TryRuntimeError> {
			Self::do_try_state()
		}
    }

    #[pallet::call]
    impl<T:Config> Pallet<T>{}

}