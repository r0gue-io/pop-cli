{{- let using_runtime_event = pallet_common_types|contains(TemplatePalletConfigCommonTypes::RuntimeEvent) -}}
{{- let using_runtime_origin = pallet_common_types|contains(TemplatePalletConfigCommonTypes::RuntimeOrigin) -}}
{{- let using_currency = pallet_common_types|contains(TemplatePalletConfigCommonTypes::Currency) -}}
//! # ^^name|capitalize^^ pallet
//! Please, document your pallet properly
//! Learn more about everything related to Polkadot SDK development at <https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/index.html>. Everythin's there!
//! - [`Config`]
//! - [`Call`]
#![cfg_attr(not(feature = "std"), no_std)]

use frame::prelude::*;

use pop_dev::{PlaceholderTraitBound, pop_todo};

{{ if using_currency }}
use frame::traits::{fungible, VariantCount};
{{- endif }}

{{ if pallet_default_config }}
pub mod config_preludes;
{{- endif }}

use pallet::*;

// A module where the main logic of the pallet is stored
mod pallet_logic;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

#[frame::pallet]
pub mod pallet {
	use super::*;

    {{ if using_runtime_origin }}
    /// An alias referencing the RuntimeOrigin config type.
    pub type RuntimeLocalOrigin<T> = <T as Config>::RuntimeOrigin;
    {{- endif }}

    {{ if using_currency }}
    /// An alias referencing the native currency's balance of an account.
    pub type BalanceOf<T> = <<T as Config>::Currency as fungible::Inspect<<T as frame_system::Config>::AccountId>>::Balance;

    /// A reason for the pallet placing a hold on funds.
	#[pallet::composite_enum]
	pub enum HoldReason {
		/// Some hold reason
		#[codec(index = 0)]
		SomeHoldReason,
	}
    {{- endif }}

    #[pallet::pallet]
	pub struct Pallet<T>(_);
    {{ if pallet_default_config }}
    #[pallet::config(with_default)]
    {{- else }}
    #[pallet::config]
    {{- endif }}
    pub trait Config: frame_system::Config{
        {{ if using_runtime_event }}
        /// The aggregated event type of the runtime.
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
        {{- endif }}

        {{ if using_runtime_origin || pallet_custom_origin }}
        /// The aggregated origin type of the runtime.
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif -}}
        {{- if pallet_custom_origin }}
        type RuntimeOrigin: From<OriginFor<Self>> + From<Origin> + Into<Result<Origin,RuntimeLocalOrigin<Self>>>;
        {{- else }}
        type RuntimeOrigin: From<OriginFor<Self>>;
        {{- endif -}}
        {{- endif }}

        {{ if using_currency }}
        /// A reason for placing a hold on funds
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeHoldReason: From<HoldReason>;

        /// A reason for placing a freeze on funds
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeFreezeReason: VariantCount;
        
        /// Type to access the native currency of the blockchain
        {{- if pallet_default_config }}
        #[pallet::no_default]
        {{- endif }}
		type Currency: fungible::Inspect<Self::AccountId>
			+ fungible::Mutate<Self::AccountId>
			+ fungible::hold::Inspect<Self::AccountId>
			+ fungible::hold::Mutate<Self::AccountId, Reason = Self::RuntimeHoldReason>
			+ fungible::freeze::Inspect<Self::AccountId>
			+ fungible::freeze::Mutate<Self::AccountId>;
        {{- endif }}

        {{ for config_type in pallet_config_types -}}
        /// Some docs for this type
        {{- match config_type.1 -}}
        {{- when TemplatePalletConfigTypesDefault::NoDefaultBounds }}
        #[pallet::no_default_bounds]
        {{- when TemplatePalletConfigTypesDefault::NoDefault }}
        #[pallet::no_default]
        {{- else -}}
        {{- endmatch }}
        {{- match config_type.0 -}}
        {{- when TemplatePalletConfigTypesMetadata::Constant }}
        #[pallet::constant]
        type ^^config_type.2|capitalize^^: Get<u32>;

        {{ else }}
        type ^^config_type.2|capitalize^^: PlaceholderTraitBound;

        {{ endmatch -}}
        {{ endfor }}
    }

    {{ for storage in pallet_storage }}
    /// Some docs for this storage type
    #[pallet::storage]
    {{- match storage.0 -}}
    {{- when TemplatePalletStorageTypes::StorageValue }}
    pub type ^^storage.1|capitalize^^<T: Config> = StorageValue<Value = pop_todo!(storage_value)>;

    {{ when TemplatePalletStorageTypes::StorageMap }}
    pub type ^^storage.1|capitalize^^<T: Config> = StorageMap<Hasher = pop_todo!(storage_hasher), Key = pop_todo!(storage_key), Value = pop_todo!(storage_value)>;

    {{ when TemplatePalletStorageTypes::CountedStorageMap }}
    pub type ^^storage.1|capitalize^^<T: Config> = CountedStorageMap<Hasher = pop_todo!(storage_hasher), Key = pop_todo!(storage_key), Value = pop_todo!(storage_value)>;

    {{ when TemplatePalletStorageTypes::StorageDoubleMap }}
    pub type ^^storage.1|capitalize^^<T: Config> = StorageDoubleMap<Hasher1 = pop_todo!(storage_hasher), Key1 = pop_todo!(storage_key), Hasher2 = pop_todo!(storage_hasher), Key2 = pop_todo!(storage_key), Value = pop_todo!(storage_value)>;

    {{ when TemplatePalletStorageTypes::StorageNMap }}
    pub type ^^storage.1|capitalize^^<T: Config>= StorageNMap<
        Key = (
            NMapKey<pop_todo!(storage_hasher), pop_todo!(storage_key)>,
            NMapKey<pop_todo!(storage_hasher), pop_todo!(storage_key)>,
            NMapKey<pop_todo!(storage_hasher), pop_todo!(storage_key)>
        ),
        Value = pop_todo!(storage_value)
    >;

    {{ when TemplatePalletStorageTypes::CountedStorageNMap }}
    pub type ^^storage.1|capitalize^^<T: Config> = CountedStorageNMap<
        Key = (
            NMapKey<pop_todo!(storage_hasher), pop_todo!(storage_key)>,
            NMapKey<pop_todo!(storage_hasher), pop_todo!(storage_key)>,
            NMapKey<pop_todo!(storage_hasher), pop_todo!(storage_key)>
        ),
        Value = pop_todo!(storage_value)
    >;
    
    {{ endmatch -}}
    {{- endfor -}}

    {{ if using_runtime_event }}
	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
        /// Someone did something
        SomeoneDidSomething { who: T::AccountId}
    }
    {{- endif }}

    #[pallet::error]
	pub enum Error<T> {
		/// SomethingWentWrong
		SomethingWentWrong,
    }

    {{ if pallet_genesis }}
    #[pallet::genesis_config]
    pub struct GenesisConfig<T: Config> {
        /// This is just an example of genesis configuration
        pub some_genesis_config: BlockNumberFor<T>
    }

    impl<T: Config> Default for GenesisConfig<T> {
        fn default() -> Self {
            Self { some_genesis_config: 1u32.into() }
        }
    }

    #[pallet::genesis_build]
    impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
        fn build(&self) {
            // TODO: This is just an example, maybe you wanna initialize some storage
        }
    }

    {{ endif -}}

    {{- if pallet_custom_origin }}
    #[pallet::origin]
    #[derive(PartialEq, Eq, Clone, RuntimeDebug, Encode, Decode, TypeInfo, MaxEncodedLen)]
    pub enum Origin {
        {{- for variant in pallet_custom_origin_variants }}
            ^^variant|capitalize^^,
        {{- endfor -}}
    }

    {{ endif -}}

    #[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        fn integrity_test(){
            // TODO: Maybe ensure something about your config types...
        }

		#[cfg(feature = "try-runtime")]
		fn try_state(_: BlockNumberFor<T>) -> Result<(), sp_runtime::TryRuntimeError> {
			Self::do_try_state()
		}
    }

    #[pallet::call]
    impl<T:Config> Pallet<T>{}

}