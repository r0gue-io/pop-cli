{{- let using_runtime_event = pallet_common_types|contains(TemplatePalletConfigCommonTypes::RuntimeEvent) -}}
{{- let using_runtime_origin = pallet_common_types|contains(TemplatePalletConfigCommonTypes::RuntimeOrigin) -}}
{{- let using_currency = pallet_common_types|contains(TemplatePalletConfigCommonTypes::Currency) -}}
//! # ^^name|capitalize^^ pallet
//! Please, document your pallet properly
//! Learn more about everything related to Polkadot SDK development at <https://paritytech.github.io/polkadot-sdk/master/polkadot_sdk_docs/index.html>. Everythin's there!
//! - [`Config`]
//! - [`Call`]
#![cfg_attr(not(feature = "std"), no_std)]

use frame::prelude::*;

{{ if using_currency }}
use frame::traits::{fungible, VariantCount};
{{- endif }}

{{ if pallet_default_config }}
pub mod config_preludes;
{{- endif }}

use pallet::*;

// A module where the main logic of the pallet is stored
mod pallet_logic;

// A module where the types used in the pallet are stored
mod types;
pub use types::*;

#[cfg(test)]
mod mock;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

#[frame::pallet]
pub mod pallet {
	use super::*;

    {{ if using_currency }}
    /// A reason for the pallet placing a hold on funds.
    #[pallet::composite_enum]
    pub enum HoldReason {
        /// Some hold reason
        #[codec(index = 0)]
        SomeHoldReason,
    }
    {{ endif }}

    #[pallet::pallet]
	pub struct Pallet<T>(_);
    {{ if pallet_default_config }}
    #[pallet::config(with_default)]
    {{- else }}
    #[pallet::config]
    {{- endif }}
    pub trait Config: frame_system::Config{
        {{ if using_runtime_event }}
        /// The aggregated event type of the runtime.
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
        {{- endif }}

        {{ if using_runtime_origin || pallet_custom_origin }}
        /// The aggregated origin type of the runtime.
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif -}}
        {{- if pallet_custom_origin }}
        type RuntimeOrigin: From<OriginFor<Self>> + From<Origin<Self>> + Into<Result<Origin<Self>,RuntimeLocalOrigin<Self>>>;
        {{- else }}
        type RuntimeOrigin: From<OriginFor<Self>>;
        {{- endif -}}
        {{- endif }}

        {{ if using_currency }}
        /// A reason for placing a hold on funds
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeHoldReason: From<HoldReason>;

        /// A reason for placing a freeze on funds
        {{- if pallet_default_config }}
        #[pallet::no_default_bounds]
        {{- endif }}
		type RuntimeFreezeReason: VariantCount;
        
        /// Type to access the native currency of the blockchain
        {{- if pallet_default_config }}
        #[pallet::no_default]
        {{- endif }}
		type Currency: fungible::Inspect<Self::AccountId>
			+ fungible::Mutate<Self::AccountId>
			+ fungible::hold::Inspect<Self::AccountId>
			+ fungible::hold::Mutate<Self::AccountId, Reason = Self::RuntimeHoldReason>
			+ fungible::freeze::Inspect<Self::AccountId>
			+ fungible::freeze::Mutate<Self::AccountId>;
        {{- endif }}

    }

    {{ if pallet_storage|contains(TemplatePalletStorageTypes::StorageValue) }}
    /// A simple StorageValue, storing a u32
    #[pallet::storage]
    pub type MyStorageValue<T:Config> = StorageValue<Value = u32>;
    {{ endif }}

    {{ if pallet_storage|contains(TemplatePalletStorageTypes::StorageMap) }}
    /// A simple StorageMap, mapping AccountIds with AccountsInfo! Using Twox64Concat as Hasher is Ok cause T::AccountId is generated by a cryptographically secure hash function, so the keys won't create an unbalanced trie.
    #[pallet::storage]
    pub type MyStorageMap<T:Config> = StorageMap<Hasher = Twox64Concat, Key = T::AccountId, Value = AccountInfo<T>>;
    {{ endif }}

    {{ if pallet_storage|contains(TemplatePalletStorageTypes::CountedStorageMap) }}
    /// A CountedStorageMap mapping u32 with some AccountIds. Blake2_128Concat is needed as Hasher to store the keys in a cryptographically secure way in order to create a balanced trie.
    #[pallet::storage]
    pub type MyCountedStorageMap<T:Config> = CountedStorageMap<Hasher = Blake2_128Concat, Key = u32, Value = T::AccountId>;
    {{ endif }}

    {{ if pallet_storage|contains(TemplatePalletStorageTypes::StorageDoubleMap) }}
    /// A StorageDoubleMap mapping AccountIds and Block Numbers to a value. The first hasher can be Twox64Concat as T::AccountId is generated by a cryptographically secure hash function, so the keys won't create an unbalanced trie, Blake2_128Concat is needed as Hasher2 to store the keys in a cryptographically secure way in order to create a balanced trie.
    #[pallet::storage]
    pub type MyStorageDoubleMap<T:Config> = StorageDoubleMap<Hasher1 = Twox64Concat, Key1 = T::AccountId, Hasher2 = Blake2_128Concat, Key2 = BlockNumberFor<T>, Value = u32>;
    {{ endif }}

    {{ if pallet_storage|contains(TemplatePalletStorageTypes::StorageNMap) }}
    /// A StorageNMap mapping 3 AccountIds to a u32 value, all the hashers are Twox64Concat as T::AccountId is generated by a cryptographically secure hash function, so the keys won't create an unbalanced trie.
    #[pallet::storage]
    pub type MyStorageNMap<T: Config>= StorageNMap<
        Key = (
            NMapKey<Twox64Concat, T::AccountId>,
            NMapKey<Twox64Concat, T::AccountId>,
            NMapKey<Twox64Concat, T::AccountId>
        ),
        Value = u32
    >;
    {{ endif }}

    {{ if pallet_storage|contains(TemplatePalletStorageTypes::StorageNMap) }}
    /// A CountedStorageNMap mapping 3 AccountIds to a u32 value, all the hashers are Twox64Concat as T::AccountId is generated by a cryptographically secure hash function, so the keys won't create an unbalanced trie.
    #[pallet::storage]
    pub type MyCountedStorageNMap<T: Config>= CountedStorageNMap<
        Key = (
            NMapKey<Twox64Concat, T::AccountId>,
            NMapKey<Twox64Concat, T::AccountId>,
            NMapKey<Twox64Concat, T::AccountId>
        ),
        Value = u32
    >;
    {{ endif }}

    {{ if pallet_custom_origin }}
    /// This storage value is used to make the custom origin AllOrigins active. If it's set, all origins will be valid as that custom origin.
    #[pallet::storage]
    pub type AllOriginsAllowed<T: Config> = StorageValue<Value = ()>;
    
    /// This storage type is used to make the custom origin OnlyAuthenticatedAccounts active. Using Twox64Concat as Hasher is Ok cause T::AccountId is generated by a cryptographically secure hash function, so the keys won't create an unbalanced trie.
    #[pallet::storage]
    pub type AuthenticatedAccounts<T:Config> = StorageMap<Hasher = Twox64Concat, Key = T::AccountId, Value = ()>;
    {{ endif }}


    {{ if using_runtime_event }}
	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
        /// Someone did something
        SomeoneDidSomething { who: T::AccountId}
    }
    {{- endif }}

    #[pallet::error]
	pub enum Error<T> {
		/// SomethingWentWrong
		SomethingWentWrong,
    }

    {{ if pallet_genesis }}
    #[pallet::genesis_config]
    pub struct GenesisConfig<T: Config> {
        /// This is just an example of genesis configuration
        pub some_genesis_config: BlockNumberFor<T>
    }

    impl<T: Config> Default for GenesisConfig<T> {
        fn default() -> Self {
            Self { some_genesis_config: 1u32.into() }
        }
    }

    #[pallet::genesis_build]
    impl<T: Config> BuildGenesisConfig for GenesisConfig<T> {
        fn build(&self) {
            // TODO: This is just an example, maybe you wanna initialize some storage
        }
    }

    {{ endif -}}

    {{- if pallet_custom_origin }}
    /// Custom origin for this pallet
    #[pallet::origin]
    #[derive(PartialEq, Eq, Clone, RuntimeDebug, Encode, Decode, TypeInfo, MaxEncodedLen)]
    pub enum Origin<T: Config> {
        /// This origin's only valid if AllOriginsAllowed is set.
        AllOrigins,
        /// This origin's only valid if the inner AccountId is present in AuthenticatedAccounts.
        OnlyAuthenticatedAccounts(T::AccountId),
    }

    {{ endif -}}

    #[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
        fn integrity_test(){
            // TODO: Maybe ensure something about your config types...
        }

		#[cfg(feature = "try-runtime")]
		fn try_state(_: BlockNumberFor<T>) -> Result<(), sp_runtime::TryRuntimeError> {
			Self::do_try_state()
		}
    }

    #[pallet::call]
    impl<T:Config> Pallet<T>{}

}